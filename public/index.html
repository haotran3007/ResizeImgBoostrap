<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Resize Image Tool</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CE2XMQXHJX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-CE2XMQXHJX');
  </script>

  <!-- Firebase (giữ nguyên như bạn có) -->
  <script defer src="/__/firebase/12.8.0/firebase-app-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-auth-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-database-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-firestore-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-functions-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-messaging-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-storage-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-analytics-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-remote-config-compat.js"></script>
  <!-- ✅ XÓA dòng remote-config trùng -->
  <script defer src="/__/firebase/12.8.0/firebase-performance-compat.js"></script>
  <script defer src="/__/firebase/init.js?useEmulator=true"></script>

  <!-- Cropper.js -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.js"></script>

  <link rel="stylesheet" href="./styles.css">
  <script src="./script.js"></script>
</head>

<body class="bg-light">
  <div class="container py-4">
    <div class="row justify-content-center">
      <div class="col-lg-12">

        <div class="card shadow-sm">
          <div class="card-body">
            <h3 class="mb-3">Resize / Compress Images</h3>

            <div class="alert alert-info mb-3">
              <div class="fw-semibold mb-1">Lưu vào đúng thư mục (theo lựa chọn của bạn):</div>
              <div>
                Chrome/Edge: chọn thư mục một lần → ảnh sẽ tự động lưu vào thư mục đó (giữ nguyên tên tệp)<br>
                Trình duyệt khác: tải xuống theo cơ chế thông thường (trình duyệt quyết định vị trí lưu)
              </div>
            </div>

            <div class="card border-0 shadow-sm mb-3 guide-card">
              <div class="card-body">
                <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                  <h5 class="mb-0">Hướng dẫn sử dụng</h5>
                  <span class="badge rounded-pill text-bg-light guide-badge">Quy trình thao tác</span>
                </div>

                <div class="table-responsive mt-3">
                  <table class="table table-sm align-middle mb-0 guide-table">
                    <thead>
                      <tr>
                        <th style="width:70px;">Bước</th>
                        <th style="width:240px;">Thao tác</th>
                        <th>Nội dung</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td class="fw-semibold">1</td>
                        <td>Chọn tệp hình ảnh</td>
                        <td>Nhấn <span class="fw-semibold">Chọn ảnh</span> để chọn một hoặc nhiều hình ảnh cần xử lý
                        </td>
                      </tr>
                      <tr>
                        <td class="fw-semibold">2</td>
                        <td>Thiết lập thông số</td>
                        <td>
                          Cấu hình <span class="fw-semibold">Dung lượng mục tiêu (KB)</span>,
                          <span class="fw-semibold">Định dạng đầu ra</span>,
                          <span class="fw-semibold">Chiều rộng tối đa</span> và
                          <span class="fw-semibold">Tỷ lệ khung hình</span> (nếu cần cắt theo tỷ lệ)
                        </td>
                      </tr>
                      <tr>
                        <td class="fw-semibold">3</td>
                        <td>Chọn thư mục lưu (tùy chọn)</td>
                        <td>
                          Trên Chrome/Edge, bạn có thể chọn thư mục để hệ thống lưu trực tiếp.
                          Các trình duyệt khác sẽ tải xuống như thông thường
                        </td>
                      </tr>
                      <tr>
                        <td class="fw-semibold">4</td>
                        <td>Thực hiện xử lý và lưu</td>
                        <td>
                          Nhấn <span class="fw-semibold">Thay đổi kích thước + Lưu</span> để xử lý hàng loạt.
                          Theo dõi trạng thái tại bảng danh sách tệp và thanh tiến độ
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>

                <div class="small text-muted mt-2">
                  Lưu ý: Với ảnh chụp màn hình hoặc ảnh nhiều chữ, để đạt dung lượng nhỏ, bạn nên giảm <span
                    class="fw-semibold">Chiều rộng tối đa</span>.
                </div>
              </div>
            </div>

            <div class="row g-3 align-items-end">
              <div class="col-md-6">
                <label class="form-label">Chọn ảnh (hỗ trợ nhiều tệp)</label>

                <input id="fileInput" type="file" class="d-none" accept="image/*" multiple>

                <div class="input-group">
                  <input id="fileInputText" type="text" class="form-control" placeholder="Chọn ảnh..." readonly>
                  <button id="fileBrowseBtn" class="btn btn-outline-primary" type="button">Chọn</button>
                  <button id="clearFilesBtn" class="btn btn-outline-secondary" type="button" disabled>Xóa chọn</button>
                </div>
              </div>

              <div class="col-md-3">
                <label class="form-label">Dung lượng mục tiêu (KB)</label>
                <input id="targetKB" type="number" class="form-control" min="10" step="10" value="300">
              </div>

              <div class="col-md-3">
                <label class="form-label">Định dạng đầu ra</label>
                <select id="outFormat" class="form-select">
                  <option value="image/jpeg" selected>JPEG</option>
                  <option value="image/webp">WebP (nhẹ hơn, hiện đại)</option>
                </select>
              </div>

              <div class="col-md-3">
                <label class="form-label">Chiều rộng tối đa (px)</label>
                <input id="maxW" type="number" class="form-control" min="100" step="100" value="1200">
              </div>

              <div class="col-md-3">
                <label class="form-label">Chiều cao tối đa (px)</label>
                <input id="maxH" type="number" class="form-control" min="100" step="100" readonly placeholder="tự động">
              </div>

              <!-- Ratio controls -->
              <div class="col-md-3">
                <label class="form-label">Tỷ lệ khung hình</label>
                <select id="ratioSelect" class="form-select">
                  <option value="default" selected>Mặc định (giữ nguyên)</option>
                  <option value="1:1">1:1 (Vuông)</option>
                  <option value="4:3">4:3</option>
                  <option value="16:9">16:9</option>
                  <option value="3:4">3:4 (Dọc)</option>
                  <option value="4:5">4:5</option>
                  <option value="21:9">21:9 (Siêu rộng)</option>
                  <option value="custom">Tùy chỉnh...</option>
                </select>
              </div>

              <div class="col-md-3 d-flex gap-2">
                <div class="w-100">
                  <label class="form-label">Tùy chỉnh (Rộng)</label>
                  <input id="ratioW" type="number" class="form-control" min="1" step="1" value="16" disabled>
                </div>
                <div class="w-100">
                  <label class="form-label">Tùy chỉnh (Cao)</label>
                  <input id="ratioH" type="number" class="form-control" min="1" step="1" value="9" disabled>
                </div>
              </div>

              <div class="col-md-12 d-flex gap-2">
                <button id="pickFolderBtn" class="btn btn-outline-primary w-100" type="button">
                  1) Chọn thư mục lưu
                </button>
                <button id="startBtn" class="btn btn-primary w-100" type="button">
                  2) Thay đổi kích thước + Lưu
                </button>
              </div>

              <div class="col-md-12">
                <div id="pickedFolderInfo" class="small text-muted">
                  Chưa chọn thư mục lưu (sẽ tải xuống theo cơ chế thông thường).
                </div>
              </div>
            </div>

            <hr class="my-4">

            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="fw-semibold">Danh sách tệp</div>
              <div class="text-muted small" id="capabilities"></div>
            </div>

            <div class="table-responsive">
              <table class="table table-sm align-middle">
                <thead>
                  <tr>
                    <th style="width:44px;">#</th>
                    <th>Tên tệp</th>
                    <th class="text-end">Dung lượng gốc</th>
                    <th class="text-end">Dung lượng sau xử lý</th>
                    <th class="text-end">Chất lượng</th>
                    <th class="text-center" style="width:260px;">Crop</th>
                    <th>Trạng thái</th>
                  </tr>
                </thead>
                <tbody id="fileTableBody">
                  <tr>
                    <td colspan="7" class="text-muted">Chưa có tệp được chọn</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="mt-3">
              <div class="progress" role="progressbar" aria-label="Tiến độ">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
              </div>
              <div class="small text-muted mt-2" id="log"></div>
            </div>

          </div>
        </div>

        <div class="text-muted small mt-3">
          Gợi ý: Ảnh chụp (photo) phù hợp với JPEG/WebP. Với ảnh chụp màn hình hoặc ảnh nhiều chữ, bạn có thể cần giảm
          kích thước để đạt dung lượng thấp
        </div>

      </div>
    </div>
  </div>

  <footer>
    <div class="container">
      <div class="text-center small text-muted footer-note">
        This gift is dedicated exclusively to <span class="fw-semibold">Vu Truc</span>.
      </div>
    </div>
  </footer>

  <!-- Crop Modal -->
  <div class="modal fade" id="cropModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Chọn vùng cắt theo tỷ lệ</h5>
          <!-- ✅ nút X vẫn giữ, nhưng JS sẽ handle để không bị treo Promise -->
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Đóng"></button>
        </div>

        <div class="modal-body">
          <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-2">
            <div class="small text-muted" id="cropFileName"></div>
            <div class="btn-group btn-group-sm" role="group" aria-label="tools">
              <button class="btn btn-outline-secondary" id="cropZoomIn" type="button">Zoom +</button>
              <button class="btn btn-outline-secondary" id="cropZoomOut" type="button">Zoom -</button>
              <button class="btn btn-outline-secondary" id="cropMove" type="button">Move</button>
              <button class="btn btn-outline-secondary" id="cropCrop" type="button">Crop</button>
              <button class="btn btn-outline-secondary" id="cropReset" type="button">Reset</button>
            </div>
          </div>

          <div style="max-height:60vh; overflow:auto;">
            <img id="cropImage" alt="crop" style="max-width:100%; display:block;" />
          </div>

          <div class="small text-muted mt-2">
            Kéo khung để chọn vùng cắt. Tỷ lệ sẽ khóa theo lựa chọn Ratio.
          </div>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-outline-danger" id="cropClearBtn">
            Xóa crop (tự động)
          </button>
          <button type="button" class="btn btn-outline-secondary" id="cropSkipBtn">
            Bỏ qua (giữ nguyên)
          </button>
          <button type="button" class="btn btn-primary" id="cropApplyBtn">
            Dùng vùng cắt này
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootbox@5.5.2/bootbox.min.js"></script>

  <script>
    "use strict";

    // =========================================================
    // Cropper modal state
    // =========================================================
    let cropper = null;
    let cropModal = null;

    // Lưu crop cho từng file: [{sx,sy,sw,sh} | null]
    let manualCrops = [];
    let pickedDirHandle = null;
    let selectedFiles = [];

    // =========================================================
    // Ratio helpers
    // =========================================================
    function parseRatioValue() {
      const v = $("#ratioSelect").val();
      if (!v || v === "default") return null;

      let rw, rh;
      if (v === "custom") {
        rw = Number($("#ratioW").val());
        rh = Number($("#ratioH").val());
      } else {
        const parts = v.split(":");
        rw = Number(parts[0]);
        rh = Number(parts[1]);
      }

      if (!Number.isFinite(rw) || !Number.isFinite(rh) || rw <= 0 || rh <= 0) return null;
      return { rw, rh, r: rw / rh };
    }

    function getAspectRatioOrNaN() {
      const ratio = parseRatioValue();
      if (!ratio) return NaN;
      return ratio.r;
    }

    // =========================================================
    // Crop modal (FIXED)
    // - Trả về {action, rect?}
    // - Có handle khi user bấm X để đóng modal (không bị treo Promise)
    // - Nhớ lại crop cũ khi mở lại
    // =========================================================
    async function openCropPopupForFile(file, aspectRatio, existingRect) {
      const $modal = $("#cropModal");
      const modalEl = $modal[0];

      if (!cropModal) {
        cropModal = new bootstrap.Modal(modalEl, { backdrop: "static", keyboard: false });
      }

      $("#cropFileName").text(file.name);

      const imgEl = document.getElementById("cropImage");
      const url = URL.createObjectURL(file);
      imgEl.src = url;

      // dọn cropper cũ nếu còn
      if (cropper) { try { cropper.destroy(); } catch { } cropper = null; }

      let resolved = false;

      function detachAll() {
        $("#cropApplyBtn").off("click");
        $("#cropSkipBtn").off("click");
        $("#cropClearBtn").off("click");
        $("#cropZoomIn").off("click");
        $("#cropZoomOut").off("click");
        $("#cropMove").off("click");
        $("#cropCrop").off("click");
        $("#cropReset").off("click");
        $modal.off("shown.bs.modal");
        $modal.off("hidden.bs.modal");
      }

      function finalize(result, resolve) {
        if (resolved) return;
        resolved = true;

        // destroy cropper
        if (cropper) { try { cropper.destroy(); } catch { } cropper = null; }

        // cleanup events + url
        detachAll();
        try { URL.revokeObjectURL(url); } catch { }

        resolve(result);
      }

      return new Promise((resolve) => {
        // Init cropper khi modal shown
        $modal.one("shown.bs.modal", function () {
          cropper = new Cropper(imgEl, {
            viewMode: 1,
            autoCropArea: 0.9,
            dragMode: "crop",
            aspectRatio: Number.isFinite(aspectRatio) ? aspectRatio : NaN
          });

          // Set lại vùng crop cũ (nếu có)
          if (existingRect && existingRect.sw > 0 && existingRect.sh > 0) {
            cropper.setData({
              x: existingRect.sx,
              y: existingRect.sy,
              width: existingRect.sw,
              height: existingRect.sh
            });
          }

          // Tool buttons
          $("#cropZoomIn").on("click", () => cropper && cropper.zoom(0.1));
          $("#cropZoomOut").on("click", () => cropper && cropper.zoom(-0.1));
          $("#cropMove").on("click", () => cropper && cropper.setDragMode("move"));
          $("#cropCrop").on("click", () => cropper && cropper.setDragMode("crop"));
          $("#cropReset").on("click", () => cropper && cropper.reset());
        });

        // ✅ Nếu user bấm X (data-bs-dismiss) => hidden => resolve keep
        $modal.one("hidden.bs.modal", function () {
          // Nếu chưa resolve bởi Apply/Skip/Clear thì coi như "keep"
          if (!resolved) finalize({ action: "keep" }, resolve);
        });

        $("#cropApplyBtn").one("click", function () {
          if (!cropper) return finalize({ action: "keep" }, resolve);

          const d = cropper.getData(true);
          const rect = {
            sx: Math.round(d.x),
            sy: Math.round(d.y),
            sw: Math.round(d.width),
            sh: Math.round(d.height)
          };

          cropModal.hide();
          finalize({ action: "set", rect }, resolve);
        });

        $("#cropSkipBtn").one("click", function () {
          cropModal.hide();
          finalize({ action: "keep" }, resolve);
        });

        $("#cropClearBtn").one("click", function () {
          cropModal.hide();
          finalize({ action: "clear" }, resolve);
        });

        cropModal.show();
      });
    }

    // =========================================================
    // UI helpers
    // =========================================================
    function bbConfirm(message, title = "Xác nhận") {
      return new Promise((resolve) => {
        bootbox.confirm({
          title,
          message,
          centerVertical: true,
          backdrop: true,
          closeButton: false,
          buttons: {
            confirm: { label: "Đồng ý", className: "btn-primary" },
            cancel: { label: "Hủy", className: "btn-outline-secondary" }
          },
          callback: (result) => resolve(!!result)
        });
      });
    }

    function updateFileInputText() {
      const count = selectedFiles?.length || 0;

      if (!count) {
        $("#fileInputText").val("").attr("placeholder", "Chọn ảnh...");
        $("#clearFilesBtn").prop("disabled", true);
        return;
      }

      $("#fileInputText").val(`${count} ảnh`);
      $("#clearFilesBtn").prop("disabled", false);
    }

    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "-";
      const kb = bytes / 1024;
      if (kb < 1024) return kb.toFixed(0) + " KB";
      return (kb / 1024).toFixed(2) + " MB";
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function setLog(msg) { $("#log").text(msg); }
    function setProgress(pct) { $("#progressBar").css("width", pct + "%").attr("aria-valuenow", pct); }

    function showCapabilities() {
      const canFS = !!window.showDirectoryPicker;
      $("#capabilities").text(
        canFS ? "Lưu theo thư mục: Hỗ trợ (Chrome/Edge)" : "Lưu theo thư mục: Không hỗ trợ (tải xuống theo cơ chế thông thường)"
      );
    }

    function clearSelectedFiles() {
      selectedFiles = [];
      manualCrops = [];
      $("#fileInput").val("");

      renderTable(selectedFiles);
      updateFileInputText();
      setProgress(0);
      setLog("");
    }

    function setRowCropUI($row, hasCrop) {
      const $badge = $row.find(".crop-badge");
      const $btnClear = $row.find(".btn-crop-clear");

      if (hasCrop) {
        $badge.removeClass("text-bg-secondary").addClass("text-bg-success").text("Đã chọn");
        $btnClear.prop("disabled", false);
      } else {
        $badge.removeClass("text-bg-success").addClass("text-bg-secondary").text("Tự động");
        $btnClear.prop("disabled", true);
      }
    }

    // =========================================================
    // Table render
    // =========================================================
    function renderTable(files) {
      const $body = $("#fileTableBody");
      $body.empty();

      if (!files || files.length === 0) {
        $body.append(`<tr><td colspan="7" class="text-muted">Chưa có tệp được chọn</td></tr>`);
        return;
      }

      files.forEach((f, idx) => {
        const hasCrop = !!manualCrops[idx];
        const cropText = hasCrop ? "Đã chọn" : "Tự động";
        const cropBadgeClass = hasCrop ? "text-bg-success" : "text-bg-secondary";

        const row = `
          <tr data-idx="${idx}">
            <td>${idx + 1}</td>
            <td class="text-truncate" style="max-width:380px;" title="${f.name}">${f.name}</td>
            <td class="text-end orig">${formatBytes(f.size)}</td>
            <td class="text-end res">-</td>
            <td class="text-end q">-</td>
            <td class="text-center">
              <div class="d-flex justify-content-center align-items-center gap-2 flex-wrap">
                <span class="badge ${cropBadgeClass} crop-badge">${cropText}</span>
                <button class="btn btn-sm btn-outline-primary btn-crop" type="button">Crop</button>
                <button class="btn btn-sm btn-outline-danger btn-crop-clear" type="button" ${hasCrop ? "" : "disabled"}>
                  Xóa
                </button>
              </div>
            </td>
            <td class="status text-muted">Chờ xử lý</td>
          </tr>
        `;
        $body.append(row);
      });
    }

    // =========================================================
    // Events
    // =========================================================
    $(function () {
      showCapabilities();

      function updateMaxHFromRatio() {
        const maxW = clamp(Number($("#maxW").val()) || 1920, 100, 20000);
        const ratio = parseRatioValue();

        if (!ratio) {
          $("#maxH").val("").attr("placeholder", "tự động");
          return;
        }

        $("#maxH").removeAttr("placeholder");
        const maxH = Math.round(maxW * (ratio.rh / ratio.rw));
        $("#maxH").val(maxH);
      }

      $("#ratioSelect").on("change", function () {
        const isCustom = ($(this).val() === "custom");
        $("#ratioW").prop("disabled", !isCustom);
        $("#ratioH").prop("disabled", !isCustom);
        updateMaxHFromRatio();
      });

      $("#ratioW, #ratioH, #maxW").on("input", updateMaxHFromRatio);
      updateMaxHFromRatio();

      // File picker
      $("#fileBrowseBtn, #fileInputText").on("click", function () {
        $("#fileInput").trigger("click");
      });

      $("#fileInput").on("change", function () {
        selectedFiles = Array.from(this.files || []);
        manualCrops = new Array(selectedFiles.length).fill(null);

        renderTable(selectedFiles);
        updateFileInputText();
        setLog(selectedFiles.length ? `Đã chọn ${selectedFiles.length} ảnh.` : "");
        setProgress(0);
      });

      $("#clearFilesBtn").on("click", async function () {
        const ok = await bbConfirm("Bạn có chắc chắn muốn xóa toàn bộ ảnh đã chọn không?", "Xác nhận");
        if (!ok) return;
        clearSelectedFiles();
      });
    });

    // ✅ Crop theo từng dòng (FIXED)
    $(document).on("click", ".btn-crop", async function () {
      const $row = $(this).closest("tr");
      const idx = Number($row.data("idx"));
      const file = selectedFiles[idx];
      if (!file) return;

      const aspectRatio = getAspectRatioOrNaN();
      const existingRect = manualCrops[idx];

      const result = await openCropPopupForFile(file, aspectRatio, existingRect);

      if (result.action === "set") {
        manualCrops[idx] = result.rect;      // ✅ lưu đúng rect
      } else if (result.action === "clear") {
        manualCrops[idx] = null;             // ✅ về auto
      } // keep => giữ nguyên manualCrops[idx]

      setRowCropUI($row, !!manualCrops[idx]);
    });

    // ✅ Nút Xóa crop trong bảng (ADD)
    $(document).on("click", ".btn-crop-clear", function () {
      const $row = $(this).closest("tr");
      const idx = Number($row.data("idx"));
      if (!Number.isFinite(idx)) return;

      manualCrops[idx] = null;
      setRowCropUI($row, false);
    });

    async function ensureDirPermission(dirHandle) {
      // Một số Chrome dùng queryPermission/requestPermission
      if (!dirHandle) return false;

      // không phải browser nào cũng có 2 hàm này
      const opts = { mode: "readwrite" };

      if (dirHandle.queryPermission) {
        const q = await dirHandle.queryPermission(opts);
        if (q === "granted") return true;
      }

      if (dirHandle.requestPermission) {
        const r = await dirHandle.requestPermission(opts);
        return r === "granted";
      }

      // nếu không có API permission, cứ thử coi như OK
      return true;
    }

    $("#pickFolderBtn").on("click", async function () {
      try {
        if (!window.showDirectoryPicker) {
          await bbAlert(
            "Trình duyệt của bạn không hỗ trợ lưu trực tiếp theo thư mục. Hãy dùng Chrome/Edge (desktop).",
            "Không hỗ trợ"
          );
          pickedDirHandle = null;
          setPickedFolderUI(null);
          return;
        }

        // yêu cầu thao tác người dùng -> phải nằm trong click handler
        const dir = await window.showDirectoryPicker({ mode: "readwrite" });

        const ok = await ensureDirPermission(dir);
        if (!ok) {
          await bbAlert("Bạn chưa cấp quyền ghi vào thư mục này. Vui lòng chọn lại và cấp quyền.", "Thiếu quyền");
          pickedDirHandle = null;
          setPickedFolderUI(null);
          return;
        }

        pickedDirHandle = dir;
        setPickedFolderUI(pickedDirHandle);
        setLog("Đã chọn thư mục lưu.");
      } catch (err) {
        // user cancel là bình thường
        if (err && (err.name === "AbortError")) return;

        console.error(err);
        await bbAlert(
          `Không thể chọn thư mục.\n\nLý do thường gặp:\n- Trang chưa chạy HTTPS (trừ localhost)\n- Bị chặn bởi browser policy/iframe\n\nChi tiết: ${err?.message || err}`,
          "Lỗi"
        );
      }
    });

    // =========================================================
    // GLOBAL UI HELPERS (fix ReferenceError)
    // =========================================================
    window.setPickedFolderUI = function (dirHandle) {
      const el = document.getElementById("pickedFolderInfo");
      if (!el) return;

      if (!dirHandle) {
        el.textContent = "Chưa chọn thư mục lưu (sẽ tải xuống theo cơ chế thông thường).";
        return;
      }
      el.textContent = `Thư mục đã chọn: ${dirHandle.name}`;
    };

    window.bbAlert = function (message, title = "Thông báo") {
      return new Promise((resolve) => {
        // Nếu có bootbox thì dùng bootbox cho đẹp
        if (window.bootbox && typeof window.bootbox.alert === "function") {
          window.bootbox.alert({
            title,
            message,
            centerVertical: true,
            backdrop: true,
            closeButton: false,
            callback: resolve
          });
          return;
        }

        // Fallback nếu bootbox chưa load
        alert(`${title}\n\n${message}`);
        resolve();
      });
    };
    async function ensureDirPermission(dirHandle) {
      if (!dirHandle) return false;
      const opts = { mode: "readwrite" };

      try {
        if (dirHandle.queryPermission) {
          const q = await dirHandle.queryPermission(opts);
          if (q === "granted") return true;
        }
        if (dirHandle.requestPermission) {
          const r = await dirHandle.requestPermission(opts);
          return r === "granted";
        }
        return true;
      } catch {
        return false;
      }
    }

    async function saveBlobSmart(blob, filename) {
      // ưu tiên lưu vào thư mục đã chọn
      if (pickedDirHandle) {
        const ok = await ensureDirPermission(pickedDirHandle);
        if (ok) {
          await writeToDirectory(pickedDirHandle, blob, filename);
          return { method: "folder" };
        }
      }
      // fallback download
      triggerDownload(blob, filename);
      return { method: "download" };
    }

    let isProcessing = false;

    $("#startBtn").on("click", async function () {
      if (isProcessing) return;
      if (!selectedFiles || selectedFiles.length === 0) {
        await bbAlert("Bạn chưa chọn ảnh nào.", "Thiếu dữ liệu");
        return;
      }

      isProcessing = true;
      $("#startBtn").prop("disabled", true);
      $("#pickFolderBtn").prop("disabled", true);

      try {
        const targetKB = clamp(Number($("#targetKB").val()) || 300, 10, 200000);
        const targetBytes = Math.round(targetKB * 1024);

        const mime = $("#outFormat").val() || "image/jpeg";

        const maxW = clamp(Number($("#maxW").val()) || 1200, 100, 20000);

        // maxH: nếu ratio có thì dùng từ input maxH, không có thì coi như vô hạn
        const ratioObj = parseRatioValue();
        const ratioWH = ratioObj ? ratioObj.r : null;

        let maxH = 20000; // default "auto"
        if (ratioObj) {
          // bạn đang tính maxH theo ratio, nên dùng lại giá trị trong input
          const mh = Number($("#maxH").val());
          if (Number.isFinite(mh) && mh > 0) maxH = clamp(mh, 100, 20000);
          else maxH = clamp(Math.round(maxW * (ratioObj.rh / ratioObj.rw)), 100, 20000);
        }

        // nếu có chọn folder -> check quyền luôn trước khi chạy
        if (pickedDirHandle) {
          const ok = await ensureDirPermission(pickedDirHandle);
          if (!ok) {
            await bbAlert("Bạn chưa cấp quyền ghi vào thư mục đã chọn. Vui lòng chọn lại thư mục.", "Thiếu quyền");
            pickedDirHandle = null;
            setPickedFolderUI(null);
          }
        }

        setProgress(0);
        setLog(`Bắt đầu xử lý ${selectedFiles.length} ảnh...`);

        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i];
          updateRow(i, { status: "Đang xử lý..." });

          try {
            // 1) decode image
            const bitmap = await fileToImageBitmap(file);

            // 2) render canvas (manual crop ưu tiên, không có thì auto crop nếu ratioWH có)
            const manualCrop = manualCrops?.[i] || null;
            const canvas = drawToCanvas(bitmap, maxW, maxH, ratioWH, manualCrop);

            // 3) compress tới target size
            const result = await compressToTarget(canvas, mime, targetBytes);

            // 4) tên output
            const outName = replaceExtension(file.name, mime);

            // 5) lưu
            await saveBlobSmart(result.blob, outName);

            updateRow(i, {
              resultBytes: result.blob.size,
              quality: result.quality,
              status: "Hoàn tất",
              statusClass: "text-success"
            });
          } catch (err) {
            console.error(err);
            updateRow(i, {
              status: "Lỗi",
              statusClass: "text-danger"
            });
          }

          const pct = Math.round(((i + 1) / selectedFiles.length) * 100);
          setProgress(pct);
          setLog(`Đã xử lý ${i + 1}/${selectedFiles.length} ảnh.`);
        }

        setLog("Xong ✅");
      } finally {
        isProcessing = false;
        $("#startBtn").prop("disabled", false);
        $("#pickFolderBtn").prop("disabled", false);
      }
    });

    function updateRow(idx, patch) {
      const row = document.querySelector(`#fileTableBody tr[data-idx="${idx}"]`);
      if (!row) return;

      // Dung lượng sau xử lý
      if (patch.resultBytes != null) {
        const el = row.querySelector(".res");
        if (el) el.textContent = formatBytes(patch.resultBytes);
      }

      // Quality
      if (patch.quality != null) {
        const el = row.querySelector(".q");
        if (el) el.textContent = Number(patch.quality).toFixed(2);
      }

      // Status
      if (patch.status != null) {
        const el = row.querySelector(".status");
        if (el) {
          el.textContent = patch.status;

          // reset màu cũ
          el.classList.remove("text-muted", "text-success", "text-danger", "text-warning");

          // class màu (nếu truyền)
          if (patch.statusClass) {
            patch.statusClass.split(/\s+/).filter(Boolean).forEach(c => el.classList.add(c));
          } else {
            // default màu theo trạng thái
            if (patch.status.includes("Lỗi")) el.classList.add("text-danger");
            else if (patch.status.includes("Hoàn tất") || patch.status.includes("Xong")) el.classList.add("text-success");
            else el.classList.add("text-muted");
          }
        }
      }
    }

    async function fileToImageBitmap(file) {
      if (typeof createImageBitmap === "function") {
        return await createImageBitmap(file);
      }

      // Fallback: load vào Image rồi trả về {width,height,image}
      const url = URL.createObjectURL(file);
      try {
        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = reject;
          im.src = url;
        });

        // tạo object "giống bitmap" để drawToCanvas vẫn dùng được
        return {
          width: img.naturalWidth,
          height: img.naturalHeight,
          _img: img
        };
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    function drawToCanvas(bitmap, maxW, maxH, ratioWH /* null ok */, manualCrop /* {sx,sy,sw,sh} | null */) {
      const srcW = bitmap.width; const srcH = bitmap.height; let sx = 0, sy = 0, sw = srcW, sh = srcH; //1) manual crop nếu có 
      if (manualCrop && manualCrop.sw > 0 && manualCrop.sh > 0) {
        sx = Math.round(manualCrop.sx);
        sy = Math.round(manualCrop.sy);
        sw = Math.round(manualCrop.sw);
        sh = Math.round(manualCrop.sh);
      }
      //2) không manual => auto crop theo ratio(nếu có) 
      else if (ratioWH) {
        const crop = cropBitmapToRatio(bitmap, ratioWH);
        sx = crop.sx;
        sy = crop.sy;
        sw = crop.sw;
        sh = crop.sh;
      }

      const scale = Math.min(1, maxW / sw, maxH / sh);
      const dstW = Math.max(1, Math.round(sw * scale));
      const dstH = Math.max(1, Math.round(sh * scale));
      const canvas = document.createElement("canvas");
      canvas.width = dstW;
      canvas.height = dstH;
      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(bitmap, sx, sy, sw, sh, 0, 0, dstW, dstH); return canvas;
    }

    function cropBitmapToRatio(bitmap, targetRatioWH) {
      const srcW = bitmap.width;
      const srcH = bitmap.height;
      const srcRatio = srcW / srcH;
      if (Math.abs(srcRatio - targetRatioWH) < 0.002) {
        return { sx: 0, sy: 0, sw: srcW, sh: srcH };
      }
      let sw, sh, sx, sy;
      if (srcRatio > targetRatioWH) {
        sh = srcH; sw = Math.round(srcH * targetRatioWH);
        sx = Math.round((srcW - sw) / 2); sy = 0;
      }
      else {
        sw = srcW;
        sh = Math.round(srcW / targetRatioWH);
        sx = 0;
        sy = Math.round((srcH - sh) / 2);
      }

      return { sx, sy, sw, sh };
    }

    async function compressToTarget(canvas, mime, targetBytes) {
      let best = null;
      for (let dimAttempt = 0; dimAttempt < 6; dimAttempt++) {
        let low = 0.05, high = 0.95;
        let bestThisRound = null;
        for (let i = 0; i < 10; i++) {
          const q = (low + high) / 2;
          const blob = await canvasToBlob(canvas, mime, q);
          if (!blob) break;
          const size = blob.size;
          if (!bestThisRound || Math.abs(size - targetBytes) < Math.abs(bestThisRound.blob.size - targetBytes)) {
            bestThisRound = { blob, quality: q };
          }
          if (size > targetBytes) high = q; else low = q;
        }
        if (bestThisRound) {
          const candidate = bestThisRound;
          if (!best) {
            best = candidate;
          }
          else {
            const bestOk = best.blob.size <= targetBytes;
            const candOk = candidate.blob.size <= targetBytes;
            if (candOk && !bestOk) best = candidate;
            else if (candOk && bestOk && candidate.blob.size > best.blob.size) best = candidate;
            else if (!candOk && !bestOk && Math.abs(candidate.blob.size - targetBytes) < Math.abs(best.blob.size - targetBytes)) best = candidate;
          } if (Math.abs(candidate.blob.size - targetBytes) / targetBytes < 0.03) return candidate; if (candidate.blob.size <= targetBytes) return candidate;
        }

        const newW = Math.max(320, Math.round(canvas.width * 0.85));
        const newH = Math.max(320, Math.round(canvas.height * 0.85));
        if (newW === canvas.width && newH === canvas.height) break;

        const tmp = document.createElement("canvas");
        tmp.width = newW;
        tmp.height = newH;
        const tctx = tmp.getContext("2d", { alpha: false });
        tctx.imageSmoothingEnabled = true;
        tctx.imageSmoothingQuality = "high";
        tctx.drawImage(canvas, 0, 0, newW, newH);
        canvas = tmp;
      } return best || { blob: await canvasToBlob(canvas, mime, 0.6), quality: 0.6 };
    }

    function canvasToBlob(canvas, mime, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob), mime, quality);
      });
    }

    function replaceExtension(filename, mime) {
      const dot = filename.lastIndexOf(".");
      const base = dot > 0 ? filename.slice(0, dot) : filename;
      const ext = (mime === "image/webp") ? ".webp" : ".jpg";
      return base + ext;
    }

    async function writeToDirectory(dirHandle, blob, filename) {
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }
  </script>
</body>

</html>