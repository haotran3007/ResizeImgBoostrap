<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Resize Image Tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

  <!-- Firebase (keep as you had it) -->
  <script defer src="/__/firebase/12.8.0/firebase-app-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-auth-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-database-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-firestore-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-functions-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-messaging-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-storage-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-analytics-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-remote-config-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-remote-config-compat.js"></script>
  <script defer src="/__/firebase/12.8.0/firebase-performance-compat.js"></script>
  <script defer src="/__/firebase/init.js?useEmulator=true"></script>

  <link rel="stylesheet" href="./styles.css">
  <script src="./script.js"></script>
</head>

<body class="bg-light">
  <div class="container py-4">
    <div class="row justify-content-center">
      <div class="col-lg-10">

        <div class="card shadow-sm">
          <div class="card-body">
            <h3 class="mb-3">Resize / Compress Images to Target KB</h3>

            <div class="alert alert-info mb-3">
              <div class="fw-semibold mb-1">Saving to an exact folder:</div>
              <div>
                Chrome/Edge: pick a folder once → images are saved there automatically (same file names).<br>
                Other browsers: normal downloads (browser decides download location).
              </div>
            </div>

            <div class="row g-3 align-items-end">
              <div class="col-md-6">
                <label class="form-label">Select images (multi)</label>
                <input id="fileInput" type="file" class="form-control" accept="image/*" multiple>
              </div>

              <div class="col-md-3">
                <label class="form-label">Target size (KB)</label>
                <input id="targetKB" type="number" class="form-control" min="10" step="10" value="300">
              </div>

              <div class="col-md-3">
                <label class="form-label">Output format</label>
                <select id="outFormat" class="form-select">
                  <option value="image/jpeg" selected>JPEG</option>
                  <option value="image/webp">WebP (smaller, modern)</option>
                </select>
              </div>

              <div class="col-md-3">
                <label class="form-label">Max width (px)</label>
                <input id="maxW" type="number" class="form-control" min="100" step="100" value="1200">
              </div>

              <div class="col-md-3">
                <label class="form-label">Max height (px)</label>
                <input id="maxH" type="number" class="form-control" min="100" step="100" readonly placeholder="auto">
              </div>

              <!-- Ratio controls -->
              <div class="col-md-3">
                <label class="form-label">Ratio</label>
                <select id="ratioSelect" class="form-select">
                  <option value="default" selected>Default (keep original)</option>
                  <option value="1:1">1:1 (Square)</option>
                  <option value="4:3">4:3</option>
                  <option value="16:9">16:9</option>
                  <option value="3:4">3:4 (Portrait)</option>
                  <option value="4:5">4:5</option>
                  <option value="21:9">21:9 (Ultra-wide)</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>

              <div class="col-md-3 d-flex gap-2">
                <div class="w-100">
                  <label class="form-label">Custom W</label>
                  <input id="ratioW" type="number" class="form-control" min="1" step="1" value="16" disabled>
                </div>
                <div class="w-100">
                  <label class="form-label">Custom H</label>
                  <input id="ratioH" type="number" class="form-control" min="1" step="1" value="9" disabled>
                </div>
              </div>

              <div class="col-md-6 d-flex gap-2">
                <button id="pickFolderBtn" class="btn btn-outline-primary w-100" type="button">
                  1) Pick output folder
                </button>
                <button id="startBtn" class="btn btn-primary w-100" type="button">
                  2) Resize + Save
                </button>
              </div>
            </div>

            <hr class="my-4">

            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="fw-semibold">Files</div>
              <div class="text-muted small" id="capabilities"></div>
            </div>

            <div class="table-responsive">
              <table class="table table-sm align-middle">
                <thead>
                  <tr>
                    <th style="width:44px;">#</th>
                    <th>Name</th>
                    <th class="text-end">Original</th>
                    <th class="text-end">Result</th>
                    <th class="text-end">Quality</th>
                    <th>Status</th>
                  </tr>
                </thead>
                <tbody id="fileTableBody">
                  <tr>
                    <td colspan="6" class="text-muted">No files selected</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="mt-3">
              <div class="progress" role="progressbar" aria-label="Progress">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
              </div>
              <div class="small text-muted mt-2" id="log"></div>
            </div>

          </div>
        </div>

        <div class="text-muted small mt-3">
          Tip: For photos, JPEG/WebP works best. For screenshots/text-heavy images, you may need lower max dimensions to
          reach a small KB.
        </div>

      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "-";
      const kb = bytes / 1024;
      if (kb < 1024) return kb.toFixed(0) + " KB";
      return (kb / 1024).toFixed(2) + " MB";
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function replaceExtension(filename, mime) {
      const dot = filename.lastIndexOf(".");
      const base = dot > 0 ? filename.slice(0, dot) : filename;
      const ext = (mime === "image/webp") ? ".webp" : ".jpg";
      return base + ext;
    }

    async function fileToImageBitmap(file) {
      return await createImageBitmap(file);
    }

    // -----------------------------
    // Ratio helpers
    // -----------------------------
    function parseRatioValue() {
      const v = $("#ratioSelect").val();
      if (!v || v === "default") return null;

      let rw, rh;
      if (v === "custom") {
        rw = Number($("#ratioW").val());
        rh = Number($("#ratioH").val());
      } else {
        const parts = v.split(":");
        rw = Number(parts[0]);
        rh = Number(parts[1]);
      }
      if (!Number.isFinite(rw) || !Number.isFinite(rh) || rw <= 0 || rh <= 0) return null;
      return { rw, rh, r: rw / rh }; // width/height
    }

    function cropBitmapToRatio(bitmap, targetRatioWH) {
      const srcW = bitmap.width;
      const srcH = bitmap.height;
      const srcRatio = srcW / srcH;

      if (Math.abs(srcRatio - targetRatioWH) < 0.002) {
        return { sx: 0, sy: 0, sw: srcW, sh: srcH };
      }

      let sw, sh, sx, sy;

      if (srcRatio > targetRatioWH) {
        sh = srcH;
        sw = Math.round(srcH * targetRatioWH);
        sx = Math.round((srcW - sw) / 2);
        sy = 0;
      } else {
        sw = srcW;
        sh = Math.round(srcW / targetRatioWH);
        sx = 0;
        sy = Math.round((srcH - sh) / 2);
      }

      return { sx, sy, sw, sh };
    }

    function drawToCanvas(bitmap, maxW, maxH, ratioWH /* nullable */) {
      const srcW = bitmap.width;
      const srcH = bitmap.height;

      let sx = 0, sy = 0, sw = srcW, sh = srcH;

      if (ratioWH) {
        const crop = cropBitmapToRatio(bitmap, ratioWH);
        sx = crop.sx; sy = crop.sy; sw = crop.sw; sh = crop.sh;
      }

      const scale = Math.min(1, maxW / sw, maxH / sh);
      const dstW = Math.max(1, Math.round(sw * scale));
      const dstH = Math.max(1, Math.round(sh * scale));

      const canvas = document.createElement("canvas");
      canvas.width = dstW;
      canvas.height = dstH;

      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(bitmap, sx, sy, sw, sh, 0, 0, dstW, dstH);

      return canvas;
    }

    function canvasToBlob(canvas, mime, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob), mime, quality);
      });
    }

    async function compressToTarget(canvas, mime, targetBytes) {
      let best = null;

      for (let dimAttempt = 0; dimAttempt < 6; dimAttempt++) {
        let low = 0.05, high = 0.95;
        let bestThisRound = null;

        for (let i = 0; i < 10; i++) {
          const q = (low + high) / 2;
          const blob = await canvasToBlob(canvas, mime, q);
          if (!blob) break;

          const size = blob.size;

          if (!bestThisRound || Math.abs(size - targetBytes) < Math.abs(bestThisRound.blob.size - targetBytes)) {
            bestThisRound = { blob, quality: q };
          }

          if (size > targetBytes) high = q;
          else low = q;
        }

        if (bestThisRound) {
          const candidate = bestThisRound;
          if (!best) {
            best = candidate;
          } else {
            const bestOk = best.blob.size <= targetBytes;
            const candOk = candidate.blob.size <= targetBytes;

            if (candOk && !bestOk) best = candidate;
            else if (candOk && bestOk && candidate.blob.size > best.blob.size) best = candidate;
            else if (!candOk && !bestOk && Math.abs(candidate.blob.size - targetBytes) < Math.abs(best.blob.size - targetBytes)) best = candidate;
          }

          if (Math.abs(candidate.blob.size - targetBytes) / targetBytes < 0.03) {
            return candidate;
          }

          if (candidate.blob.size <= targetBytes) {
            return candidate;
          }
        }

        const newW = Math.max(320, Math.round(canvas.width * 0.85));
        const newH = Math.max(320, Math.round(canvas.height * 0.85));
        if (newW === canvas.width && newH === canvas.height) break;

        const tmp = document.createElement("canvas");
        tmp.width = newW;
        tmp.height = newH;
        const tctx = tmp.getContext("2d", { alpha: false });
        tctx.imageSmoothingEnabled = true;
        tctx.imageSmoothingQuality = "high";
        tctx.drawImage(canvas, 0, 0, newW, newH);
        canvas = tmp;
      }

      return best || { blob: await canvasToBlob(canvas, mime, 0.6), quality: 0.6 };
    }

    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    }

    async function writeToDirectory(dirHandle, blob, filename) {
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    // -----------------------------
    // UI state
    // -----------------------------
    let pickedDirHandle = null;
    let selectedFiles = [];

    function setLog(msg) { $("#log").text(msg); }
    function setProgress(pct) { $("#progressBar").css("width", pct + "%").attr("aria-valuenow", pct); }

    function renderTable(files) {
      const $body = $("#fileTableBody");
      $body.empty();

      if (!files || files.length === 0) {
        $body.append(`<tr><td colspan="6" class="text-muted">No files selected</td></tr>`);
        return;
      }

      files.forEach((f, idx) => {
        const row = `
          <tr data-idx="${idx}">
            <td>${idx + 1}</td>
            <td class="text-truncate" style="max-width:380px;" title="${f.name}">${f.name}</td>
            <td class="text-end orig">${formatBytes(f.size)}</td>
            <td class="text-end res">-</td>
            <td class="text-end q">-</td>
            <td class="status text-muted">Pending</td>
          </tr>
        `;
        $body.append(row);
      });
    }

    function updateRow(idx, patch) {
      const $row = $(`#fileTableBody tr[data-idx="${idx}"]`);
      if (!$row.length) return;
      if (patch.resultBytes != null) $row.find(".res").text(formatBytes(patch.resultBytes));
      if (patch.quality != null) $row.find(".q").text((patch.quality).toFixed(2));
      if (patch.status != null) $row.find(".status").text(patch.status).removeClass("text-muted").addClass(patch.statusClass || "");
      if (patch.statusClass) $row.find(".status").addClass(patch.statusClass);
    }

    function showCapabilities() {
      const canFS = !!window.showDirectoryPicker;
      $("#capabilities").text(canFS ? "Folder save: Supported (Chrome/Edge)" : "Folder save: Not supported (will download normally)");
    }

    // -----------------------------
    // Events
    // -----------------------------
    $(function () {
      showCapabilities();

      // Keep maxH synced with ratio/maxW
      function updateMaxHFromRatio() {
        const maxW = clamp(Number($("#maxW").val()) || 1920, 100, 20000);
        const ratio = parseRatioValue();

        if (!ratio) {
          $("#maxH").val("");                 // ✅ clear when Default
          $("#maxH").attr("placeholder", "auto");
          return;
        }

        $("#maxH").removeAttr("placeholder");

        const maxH = Math.round(maxW * (ratio.rh / ratio.rw));
        $("#maxH").val(maxH);
      }

      $("#ratioSelect").on("change", function () {
        const v = $(this).val();
        const isCustom = (v === "custom");
        $("#ratioW").prop("disabled", !isCustom);
        $("#ratioH").prop("disabled", !isCustom);
        updateMaxHFromRatio();
      });

      $("#ratioW, #ratioH, #maxW").on("input", function () {
        updateMaxHFromRatio();
      });

      // init
      updateMaxHFromRatio();

      $("#fileInput").on("change", function () {
        selectedFiles = Array.from(this.files || []);
        renderTable(selectedFiles);
        setLog(selectedFiles.length ? `${selectedFiles.length} file(s) selected.` : "");
        setProgress(0);
      });

      $("#pickFolderBtn").on("click", async function () {
        try {
          if (!window.showDirectoryPicker) {
            alert("Your browser does not support folder picking. Use Chrome or Edge for saving into a chosen folder.");
            return;
          }
          pickedDirHandle = await window.showDirectoryPicker({ mode: "readwrite" });
          alert("Folder selected. Now click “Resize + Save”.");
        } catch (e) {
          console.warn(e);
        }
      });

      $("#startBtn").on("click", async function () {
        if (!selectedFiles.length) {
          alert("Please select images first.");
          return;
        }

        const targetKB = Number($("#targetKB").val());
        const targetBytes = Math.max(10, targetKB) * 1024;

        const mime = $("#outFormat").val();

        const maxW = clamp(Number($("#maxW").val()) || 1920, 100, 20000);

        // ✅ empty maxH => treat as unlimited
        const rawMaxH = $("#maxH").val();
        const maxH = rawMaxH === "" ? 20000 : clamp(Number(rawMaxH) || 20000, 100, 20000);

        const ratio = parseRatioValue();        // null if default
        const ratioWH = ratio ? ratio.r : null; // width/height

        setProgress(0);
        setLog("Processing...");

        if (pickedDirHandle) {
          try {
            const perm = await pickedDirHandle.queryPermission({ mode: "readwrite" });
            if (perm !== "granted") {
              const req = await pickedDirHandle.requestPermission({ mode: "readwrite" });
              if (req !== "granted") {
                pickedDirHandle = null;
                alert("Folder permission not granted. Will fall back to normal downloads.");
              }
            }
          } catch (e) {
            console.warn(e);
            pickedDirHandle = null;
          }
        }

        for (let i = 0; i < selectedFiles.length; i++) {
          const f = selectedFiles[i];
          updateRow(i, { status: "Working...", statusClass: "text-primary" });

          try {
            const bitmap = await fileToImageBitmap(f);

            const canvas = drawToCanvas(bitmap, maxW, maxH, ratioWH);

            const result = await compressToTarget(canvas, mime, targetBytes);
            const outName = replaceExtension(f.name, mime);

            updateRow(i, {
              resultBytes: result.blob.size,
              quality: result.quality,
              status: pickedDirHandle ? "Saved to folder" : "Downloaded",
              statusClass: "text-success"
            });

            if (pickedDirHandle) {
              await writeToDirectory(pickedDirHandle, result.blob, outName);
            } else {
              triggerDownload(result.blob, outName);
            }

          } catch (err) {
            console.error(err);
            updateRow(i, { status: "Failed", statusClass: "text-danger" });
          }

          setProgress(Math.round(((i + 1) / selectedFiles.length) * 100));
          setLog(`Processed ${i + 1}/${selectedFiles.length}`);
        }

        setLog("Done.");
      });
    });
  </script>
</body>

</html>