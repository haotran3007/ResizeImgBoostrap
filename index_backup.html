<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resize Image Tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
</head>
<body class="bg-light">
  <div class="container py-4">
    <div class="row justify-content-center">
      <div class="col-lg-10">

        <div class="card shadow-sm">
          <div class="card-body">
            <h3 class="mb-3">Resize / Compress Images to Target KB</h3>

            <div class="alert alert-info mb-3">
              <div class="fw-semibold mb-1">Saving to an exact folder:</div>
              <div>
                Chrome/Edge: pick a folder once → images are saved there automatically (same file names).<br>
                Other browsers: normal downloads (browser decides download location).
              </div>
            </div>

            <div class="row g-3 align-items-end">
              <div class="col-md-6">
                <label class="form-label">Select images (multi)</label>
                <input id="fileInput" type="file" class="form-control" accept="image/*" multiple>
              </div>

              <div class="col-md-3">
                <label class="form-label">Target size (KB)</label>
                <input id="targetKB" type="number" class="form-control" min="10" step="10" value="300">
              </div>

              <div class="col-md-3">
                <label class="form-label">Output format</label>
                <select id="outFormat" class="form-select">
                  <option value="image/jpeg" selected>JPEG</option>
                  <option value="image/webp">WebP (smaller, modern)</option>
                </select>
              </div>

              <div class="col-md-3">
                <label class="form-label">Max width (px)</label>
                <input id="maxW" type="number" class="form-control" min="100" step="100" value="1200">
              </div>

              <div class="col-md-3">
                <label class="form-label">Max height (px)</label>
                <input id="maxH" type="number" class="form-control" min="100" step="100" readonly>
              </div>

              <div class="col-md-6 d-flex gap-2">
                <button id="pickFolderBtn" class="btn btn-outline-primary w-100" type="button">
                  1) Pick output folder
                </button>
                <button id="startBtn" class="btn btn-primary w-100" type="button">
                  2) Resize + Save
                </button>
              </div>
            </div>

            <hr class="my-4">

            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="fw-semibold">Files</div>
              <div class="text-muted small" id="capabilities"></div>
            </div>

            <div class="table-responsive">
              <table class="table table-sm align-middle">
                <thead>
                  <tr>
                    <th style="width:44px;">#</th>
                    <th>Name</th>
                    <th class="text-end">Original</th>
                    <th class="text-end">Result</th>
                    <th class="text-end">Quality</th>
                    <th>Status</th>
                  </tr>
                </thead>
                <tbody id="fileTableBody">
                  <tr><td colspan="6" class="text-muted">No files selected</td></tr>
                </tbody>
              </table>
            </div>

            <div class="mt-3">
              <div class="progress" role="progressbar" aria-label="Progress">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
              </div>
              <div class="small text-muted mt-2" id="log"></div>
            </div>

          </div>
        </div>

        <div class="text-muted small mt-3">
          Tip: For photos, JPEG/WebP works best. For screenshots/text-heavy images, you may need lower max dimensions to reach a small KB.
        </div>

      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "-";
      const kb = bytes / 1024;
      if (kb < 1024) return kb.toFixed(0) + " KB";
      return (kb / 1024).toFixed(2) + " MB";
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function replaceExtension(filename, mime) {
      const dot = filename.lastIndexOf(".");
      const base = dot > 0 ? filename.slice(0, dot) : filename;
      const ext = (mime === "image/webp") ? ".webp" : ".jpg";
      return base + ext;
    }

    async function fileToImageBitmap(file) {
      // HaoTV - createImageBitmap is fast and avoids <img> decoding issues
      return await createImageBitmap(file);
    }

    function drawToCanvas(bitmap, maxW, maxH) {
      const srcW = bitmap.width;
      const srcH = bitmap.height;

      const scale = Math.min(1, maxW / srcW, maxH / srcH);
      const dstW = Math.max(1, Math.round(srcW * scale));
      const dstH = Math.max(1, Math.round(srcH * scale));

      const canvas = document.createElement("canvas");
      canvas.width = dstW;
      canvas.height = dstH;

      const ctx = canvas.getContext("2d", { alpha: false });
      // better quality downscale
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(bitmap, 0, 0, dstW, dstH);

      return canvas;
    }

    function canvasToBlob(canvas, mime, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob), mime, quality);
      });
    }

    async function compressToTarget(canvas, mime, targetBytes) {
      // Strategy:
      // 1) Binary search JPEG/WebP quality to hit target
      // 2) If still too large at low quality, step down dimensions and retry

      let best = null;

      // Try a few rounds of dimension reduction if needed
      for (let dimAttempt = 0; dimAttempt < 6; dimAttempt++) {
        // Binary search quality (0.05..0.95)
        let low = 0.05, high = 0.95;
        let bestThisRound = null;

        for (let i = 0; i < 10; i++) {
          const q = (low + high) / 2;
          const blob = await canvasToBlob(canvas, mime, q);
          if (!blob) break;

          const size = blob.size;

          // Keep the closest under-or-equal target as "best", but also store closest overall fallback
          if (!bestThisRound || Math.abs(size - targetBytes) < Math.abs(bestThisRound.blob.size - targetBytes)) {
            bestThisRound = { blob, quality: q };
          }

          if (size > targetBytes) {
            high = q; // need smaller
          } else {
            low = q; // can increase quality
          }
        }

        // Track best overall (prefer <= target, otherwise closest)
        if (bestThisRound) {
          const candidate = bestThisRound;
          if (!best) {
            best = candidate;
          } else {
            const bestOk = best.blob.size <= targetBytes;
            const candOk = candidate.blob.size <= targetBytes;

            if (candOk && !bestOk) best = candidate;
            else if (candOk && bestOk && candidate.blob.size > best.blob.size) best = candidate; // closer to target but under
            else if (!candOk && !bestOk && Math.abs(candidate.blob.size - targetBytes) < Math.abs(best.blob.size - targetBytes)) best = candidate;
          }

          // If we are within 3% of target, stop early
          if (Math.abs(candidate.blob.size - targetBytes) / targetBytes < 0.03) {
            return candidate;
          }

          // If we got under target, good enough—return the best under-target from this dimension
          if (candidate.blob.size <= targetBytes) {
            return candidate;
          }
        }

        // Still too large -> reduce dimensions by 85% and retry
        const newW = Math.max(320, Math.round(canvas.width * 0.85));
        const newH = Math.max(320, Math.round(canvas.height * 0.85));
        if (newW === canvas.width && newH === canvas.height) break;

        const tmp = document.createElement("canvas");
        tmp.width = newW;
        tmp.height = newH;
        const tctx = tmp.getContext("2d", { alpha: false });
        tctx.imageSmoothingEnabled = true;
        tctx.imageSmoothingQuality = "high";
        tctx.drawImage(canvas, 0, 0, newW, newH);
        canvas = tmp;
      }

      // fallback
      return best || { blob: await canvasToBlob(canvas, mime, 0.6), quality: 0.6 };
    }

    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    }

    async function writeToDirectory(dirHandle, blob, filename) {
      // Save with same name
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    // -----------------------------
    // UI state
    // -----------------------------
    let pickedDirHandle = null;
    let selectedFiles = [];

    function setLog(msg) { $("#log").text(msg); }
    function setProgress(pct) { $("#progressBar").css("width", pct + "%").attr("aria-valuenow", pct); }

    function renderTable(files) {
      const $body = $("#fileTableBody");
      $body.empty();

      if (!files || files.length === 0) {
        $body.append(`<tr><td colspan="6" class="text-muted">No files selected</td></tr>`);
        return;
      }

      files.forEach((f, idx) => {
        const row = `
          <tr data-idx="${idx}">
            <td>${idx + 1}</td>
            <td class="text-truncate" style="max-width:380px;" title="${f.name}">${f.name}</td>
            <td class="text-end orig">${formatBytes(f.size)}</td>
            <td class="text-end res">-</td>
            <td class="text-end q">-</td>
            <td class="status text-muted">Pending</td>
          </tr>
        `;
        $body.append(row);
      });
    }

    function updateRow(idx, patch) {
      const $row = $(`#fileTableBody tr[data-idx="${idx}"]`);
      if (!$row.length) return;
      if (patch.resultBytes != null) $row.find(".res").text(formatBytes(patch.resultBytes));
      if (patch.quality != null) $row.find(".q").text((patch.quality).toFixed(2));
      if (patch.status != null) $row.find(".status").text(patch.status).removeClass("text-muted").addClass(patch.statusClass || "");
      if (patch.statusClass) $row.find(".status").addClass(patch.statusClass);
    }

    function showCapabilities() {
      const canFS = !!window.showDirectoryPicker;
      $("#capabilities").text(canFS ? "Folder save: Supported (Chrome/Edge)" : "Folder save: Not supported (will download normally)");
    }

    // -----------------------------
    // Events
    // -----------------------------
    $(function() {
      showCapabilities();

      $("#fileInput").on("change", function() {
        selectedFiles = Array.from(this.files || []);
        renderTable(selectedFiles);
        setLog(selectedFiles.length ? `${selectedFiles.length} file(s) selected.` : "");
        setProgress(0);
      });

      $("#pickFolderBtn").on("click", async function() {
        try {
          if (!window.showDirectoryPicker) {
            alert("Your browser does not support folder picking. Use Chrome or Edge for saving into a chosen folder.");
            return;
          }
          pickedDirHandle = await window.showDirectoryPicker({ mode: "readwrite" });
          alert("Folder selected. Now click “Resize + Save”.");
        } catch (e) {
          // user canceled
          console.warn(e);
        }
      });

      $("#startBtn").on("click", async function() {
        if (!selectedFiles.length) {
          alert("Please select images first.");
          return;
        }

        const targetKB = Number($("#targetKB").val());
        const targetBytes = Math.max(10, targetKB) * 1024;

        const mime = $("#outFormat").val();
        const maxW = clamp(Number($("#maxW").val()) || 1920, 100, 20000);
        const maxH = clamp(Number($("#maxH").val()) || 1920, 100, 20000);

        setProgress(0);
        setLog("Processing...");

        // If folder picked, request permission once (best-effort)
        if (pickedDirHandle) {
          try {
            const perm = await pickedDirHandle.queryPermission({ mode: "readwrite" });
            if (perm !== "granted") {
              const req = await pickedDirHandle.requestPermission({ mode: "readwrite" });
              if (req !== "granted") {
                pickedDirHandle = null; // fallback to downloads
                alert("Folder permission not granted. Will fall back to normal downloads.");
              }
            }
          } catch (e) {
            console.warn(e);
            pickedDirHandle = null;
          }
        }

        for (let i = 0; i < selectedFiles.length; i++) {
          const f = selectedFiles[i];
          updateRow(i, { status: "Working...", statusClass: "text-primary" });

          try {
            const bitmap = await fileToImageBitmap(f);
            const canvas = drawToCanvas(bitmap, maxW, maxH);

            const result = await compressToTarget(canvas, mime, targetBytes);

            const outName = replaceExtension(f.name, mime);

            updateRow(i, {
              resultBytes: result.blob.size,
              quality: result.quality,
              status: pickedDirHandle ? "Saved to folder" : "Downloaded",
              statusClass: "text-success"
            });

            if (pickedDirHandle) {
              await writeToDirectory(pickedDirHandle, result.blob, outName);
            } else {
              triggerDownload(result.blob, outName);
            }

          } catch (err) {
            console.error(err);
            updateRow(i, { status: "Failed", statusClass: "text-danger" });
          }

          setProgress(Math.round(((i + 1) / selectedFiles.length) * 100));
          setLog(`Processed ${i + 1}/${selectedFiles.length}`);
        }

        setLog("Done.");
      });
    });
  </script>
</body>
</html>
